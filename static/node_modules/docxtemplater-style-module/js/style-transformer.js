"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require("./attributes"),
    setSingleAttribute = _require.setSingleAttribute;

var _require2 = require("docxtemplater/js/lexer"),
    xmlparse = _require2.xmlparse;

module.exports = function (xml, styleData, fileType) {
  xml = xmlparse(xml, {
    text: [],
    other: ["w:pStyle", "w:shd", "w:p", "w:pPr", "w:rPr", "w:bookmarkStart", "w:bookmarkEnd", "w:r", "a:tc", "a:txBody", "a:bodyPr", "a:noAutofit", "a:p", "a:pPr", "a:lnL", "a:lnR", "a:lnSpc", "a:spcPct", "a:r", "a:rPr", "a:solidFill", "a:srgbClr", "a:latin", "a:endParaRPr", "a:lnT", "a:lnB", "a:tcPr", "w:tcPr", "w:color"]
  });

  function createElement(tagName) {
    return [{
      type: "tag",
      position: "selfclosing",
      text: false,
      value: "<".concat(tagName, "/>"),
      tag: tagName
    }];
  }

  function appendChild(parent, child) {
    if (!(child instanceof Array)) {
      child = [child];
    }

    if (parent instanceof Array) {
      throw new Error("appendChild should not use array");
    }

    var iii = xml.indexOf(parent);
    var isSelfClosing = parent.position === "selfclosing";

    if (isSelfClosing) {
      var _xml;

      var el0Tag = parent.tag;
      parent.value = parent.value.replace(/\/>$/, ">");
      parent.position = "start";
      var endingTag = {
        type: "tag",
        position: "end",
        text: false,
        value: "</".concat(el0Tag, ">"),
        tag: el0Tag
      };

      (_xml = xml).splice.apply(_xml, [iii + 1, 0].concat(_toConsumableArray(child.concat(endingTag))));
    } else {
      var _xml2;

      var next = null;

      while (next == null && iii < xml.length - 1) {
        iii++;
        var part = xml[iii];

        if (part.tag === parent.tag && part.position === "end") {
          next = part;
        }
      }

      (_xml2 = xml).splice.apply(_xml2, [iii, 0].concat(_toConsumableArray(child)));
    }
  } // styleData = { textColor: "#449955"}


  function setAttr(el, attrName, attrValue) {
    if (el instanceof Array) {
      el[0].value = setSingleAttribute(el[0].value, attrName, attrValue);
    } else {
      el.value = setSingleAttribute(el.value, attrName, attrValue);
    }
  }

  function getOrCreate(element, tagName) {
    var found = false;
    element.some(function (part) {
      if (part.tag === tagName) {
        found = part;
        return true;
      }
    });

    if (found) {
      return found;
    }

    var newTag = {
      type: "tag",
      position: "selfclosing",
      text: false,
      value: "<".concat(tagName, "/>"),
      tag: tagName
    };
    appendChild(element[0], newTag);
    return newTag;
  }

  function getDirectChildOrCreate(element, tagName) {
    var found = false;
    var level = 0;
    element.some(function (part) {
      if (part.tag === tagName && part.position === "selfclosing" && level === 1) {
        found = part;
        return true;
      }

      if (part.position === "start") {
        level++;

        if (part.tag === tagName && level === 2) {
          found = part;
          return true;
        }
      }

      if (part.position === "end") {
        level--;
      }
    });

    if (found) {
      return found;
    }

    var newTag = {
      type: "tag",
      position: "selfclosing",
      text: false,
      value: "<".concat(tagName, "/>"),
      tag: tagName
    };
    appendChild(element[0], newTag);
    return newTag;
  }

  function removeAllChildren(element) {
    var start = xml.indexOf(element);

    if (element.position !== "start") {
      return;
    }

    var end = start;

    while (end < xml.length - 1) {
      end++;
      var part = xml[end];

      if (part.tag === element.tag && part.position === "end") {
        xml.splice(start + 1, end - start - 1);
        return;
      }
    }
  }

  function forEachTag(tagName, fn) {
    var interestingParts = [];

    for (var i = 0, len = xml.length; i < len; i++) {
      var part = xml[i];
      var type = part.type,
          position = part.position,
          tag = part.tag;

      if (type === "tag" && position === "selfclosing" && tag === tagName) {
        interestingParts.push([part]);
        continue;
      }

      if (type === "tag" && position === "start" && tag === tagName) {
        interestingParts.push([part]);
      }

      if (type === "tag" && position === "end" && tag === tagName) {
        interestingParts[interestingParts.length - 1].push(part);
      }
    }

    interestingParts.forEach(function (parts) {
      if (parts.length === 1) {
        fn(parts);
      } else {
        var startIndex = xml.indexOf(parts[0]);
        var endIndex = xml.indexOf(parts[1]);
        fn(xml.slice(startIndex, endIndex + 1));
      }
    });
    return xml;
  }

  if (styleData.cellBackground) {
    var fill = styleData.cellBackground.substr(1).toUpperCase();

    if (fileType === "docx") {
      forEachTag("w:tcPr", function (cellProp) {
        var shade = getOrCreate(cellProp, "w:shd");
        setAttr(shade, "w:fill", fill);
      });
    }

    if (fileType === "pptx") {
      forEachTag("a:tcPr", function (cellProp) {
        var shade = getDirectChildOrCreate(cellProp, "a:solidFill");
        var srgb = createElement("a:srgbClr");
        setAttr(srgb, "val", fill);
        removeAllChildren(shade);
        appendChild(shade, srgb);
      });
    }
  }

  if (styleData.textColor) {
    var colorText = styleData.textColor.substr(1).toUpperCase();

    if (fileType === "docx") {
      forEachTag("w:rPr", function (runProp) {
        var color = getOrCreate(runProp, "w:color");
        setAttr(color, "w:val", colorText);
      });
    }

    if (fileType === "pptx") {
      forEachTag("a:rPr", function (runProp) {
        var shade = getDirectChildOrCreate(runProp, "a:solidFill");
        removeAllChildren(shade);
        var srgb = createElement("a:srgbClr");
        setAttr(srgb, "val", colorText);
        appendChild(shade, srgb);
      });
    }
  }

  if (styleData.fontFamily) {
    var fontFamily = styleData.fontFamily;

    if (fileType === "docx") {
      forEachTag("w:rPr", function (runProp) {
        var el = getOrCreate(runProp, "w:rFonts");
        setAttr(el, "w:ascii", fontFamily);
        setAttr(el, "w:hAnsi", fontFamily);
      });
    }

    if (fileType === "pptx") {
      forEachTag("a:rPr", function (runProp) {
        var latin = getDirectChildOrCreate(runProp, "a:latin");
        setAttr(latin, "typeface", fontFamily);
      });
    }
  }

  if (styleData.pStyle && fileType === "docx") {
    var pStyle = styleData.pStyle;
    forEachTag("w:pPr", function (parProp) {
      var el = getOrCreate(parProp, "w:pStyle");
      setAttr(el, "w:val", pStyle);
    });
  }

  return xml.map(function (_ref) {
    var value = _ref.value;
    return value;
  }).join("");
};