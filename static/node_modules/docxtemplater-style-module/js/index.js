"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var verifyApiVersion = require("./api-verify");

var _require$DocUtils = require("docxtemplater").DocUtils,
    traits = _require$DocUtils.traits,
    mergeObjects = _require$DocUtils.mergeObjects,
    concatArrays = _require$DocUtils.concatArrays;

var moduleNameCell = "pro-xml-templating/style-cell";
var moduleNameRow = "pro-xml-templating/style-row";
var moduleNameParagraph = "pro-xml-templating/style-paragraph";
var modules = {
  cell: moduleNameCell,
  paragraph: moduleNameParagraph,
  row: moduleNameRow
};

function getValues(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

var moduleNames = getValues(modules);

var styleTransformer = require("./style-transformer");

function getInner(_ref) {
  var part = _ref.part,
      leftParts = _ref.leftParts,
      rightParts = _ref.rightParts,
      postparse = _ref.postparse;
  part.subparsed = postparse(concatArrays([leftParts, rightParts]));
  return part;
}

var StyleModule = /*#__PURE__*/function () {
  function StyleModule(options) {
    _classCallCheck(this, StyleModule);

    this.requiredAPIVersion = "3.24.0";
    this.supportedFileTypes = ["docx", "pptx"];
    this.options = options || {};
    this.name = "StyleModule";
    this.prefix = {
      cell: ":stylecell",
      paragraph: ":stylepar",
      row: ":stylerow"
    };
  }

  _createClass(StyleModule, [{
    key: "set",
    value: function set(options) {
      if (options.xmlDocuments) {
        this.xmlDocuments = options.xmlDocuments;
      }
    }
  }, {
    key: "optionsTransformer",
    value: function optionsTransformer(options, docxtemplater) {
      verifyApiVersion(docxtemplater, this.requiredAPIVersion);
      this.fileType = docxtemplater.fileType;
      var relsFiles = docxtemplater.zip.file(/numbering.xml/).concat(docxtemplater.zip.file(/\[Content_Types\].xml/)).concat(docxtemplater.zip.file(/word\/styles\.xml/)).concat(docxtemplater.zip.file(/document.xml.rels/)).map(function (file) {
        return file.name;
      });
      options.xmlFileNames = options.xmlFileNames.concat(relsFiles);
      docxtemplater.fileTypeConfig.tagsXmlLexedArray.push("w:ascii", "w:color", "w:fill", "w:hAnsi", "w:pPr", "w:rFonts", "w:rPr", "w:shd", "w:spacing", "w:tcPr", "w:tcW", "w:tr", "w:tc", "a:tc", "a:tr", "w:val");
      return options;
    }
  }, {
    key: "parse",
    value: function parse(placeHolderContent) {
      var type = "placeholder";
      var module;
      var candidates = Object.keys(modules);

      for (var i = 0, len = candidates.length; i < len; i++) {
        var candidate = candidates[i];

        if (placeHolderContent.indexOf(this.prefix[candidate]) === 0) {
          module = modules[candidate];
          return {
            type: type,
            value: placeHolderContent.substr(this.prefix[candidate].length + 1),
            module: module
          };
        }
      }

      return null;
    }
  }, {
    key: "postparse",
    value: function postparse(parsed, _ref2) {
      var _postparse = _ref2.postparse;

      if (this.fileType === "docx") {
        parsed = traits.expandToOne(parsed, {
          moduleName: moduleNameRow,
          getInner: getInner,
          expandTo: "w:tr",
          postparse: _postparse
        });
        parsed = traits.expandToOne(parsed, {
          moduleName: moduleNameCell,
          getInner: getInner,
          expandTo: "w:tc",
          postparse: _postparse
        });
        parsed = traits.expandToOne(parsed, {
          moduleName: moduleNameParagraph,
          getInner: getInner,
          expandTo: "w:p",
          postparse: _postparse
        });
      }

      if (this.fileType === "pptx") {
        parsed = traits.expandToOne(parsed, {
          moduleName: moduleNameRow,
          getInner: getInner,
          expandTo: "a:tr",
          postparse: _postparse
        });
        parsed = traits.expandToOne(parsed, {
          moduleName: moduleNameCell,
          getInner: getInner,
          expandTo: "a:tc",
          postparse: _postparse
        });
        parsed = traits.expandToOne(parsed, {
          moduleName: moduleNameParagraph,
          getInner: getInner,
          expandTo: "a:p",
          postparse: _postparse
        });
      }

      return parsed;
    }
  }, {
    key: "render",
    value: function render(part, options) {
      if (part.type !== "placeholder" || moduleNames.indexOf(part.module) === -1) {
        return null;
      }

      var styleData = options.scopeManager.getValue(part.value, {
        part: part
      }) || {};
      var totalValue = [];
      var errors = [];
      var parts = concatArrays(part.expanded);
      var subRendered = options.render(mergeObjects({}, options, {
        compiled: parts,
        tags: {},
        scopeManager: options.scopeManager
      }));
      totalValue = totalValue.concat(subRendered.parts);
      var strValue = totalValue.join("");
      var value = styleTransformer(strValue, styleData, this.fileType);
      errors = errors.concat(subRendered.errors || []);
      return {
        value: value,
        errors: errors
      };
    }
  }, {
    key: "resolve",
    value: function resolve(part, options) {
      if (part.type !== "placeholder" || moduleNames.indexOf(part.module) === -1) {
        return null;
      }

      var sm = options.scopeManager;
      var promisedValue = Promise.resolve().then(function () {
        return sm.getValue(part.value, {
          part: part
        });
      }); // const promises = [];
      // function loopOver(scope, i, length) {
      // 	const scopeManager = sm.createSubScopeManager(
      // 		scope,
      // 		part.value,
      // 		i,
      // 		part,
      // 		length
      // 	);
      // 	promises.push(
      // 		options.resolve({
      // 			filePath: options.filePath,
      // 			modules: options.modules,
      // 			baseNullGetter: options.baseNullGetter,
      // 			resolve: options.resolve,
      // 			compiled: part.subparsed,
      // 			tags: {},
      // 			scopeManager,
      // 		})
      // 	);
      // }
      // const errorList = [];

      return promisedValue.then(function (value) {
        return options.resolve({
          filePath: options.filePath,
          modules: options.modules,
          baseNullGetter: options.baseNullGetter,
          resolve: options.resolve,
          compiled: part.subparsed,
          tags: {},
          scopeManager: sm
        }).then(function (res) {
          return [value].concat(res);
        }); // sm.loopOverValue(value, loopOver, part.inverted);
        // return Promise.all(promises)
        // 	.then(function (r) {
        // 		return r.map(function ({ resolved, errors }) {
        // 			if (errors.length > 0) {
        // 				errorList.push(...errors);
        // 			}
        // 			return resolved;
        // 		});
        // 	})
        // 	.then(function (value) {
        // 		if (errorList.length > 0) {
        // 			throw errorList;
        // 		}
        // 		return value;
        // 	});
      });
    }
  }]);

  return StyleModule;
}();

module.exports = StyleModule;